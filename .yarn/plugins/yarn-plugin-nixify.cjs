module.exports={name:"yarn-plugin-nixify",factory:function(e){return(()=>{"use strict";var t={540:(e,t,n)=>{n.r(t),n.d(t,{default:()=>k});var i,r,a,o,s,c=n(42),l=n(966);function p(e,t,n,i,r){var a={};return Object.keys(i).forEach((function(e){a[e]=i[e]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=n.slice().reverse().reduce((function(n,i){return i(e,t,n)||n}),a),r&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(r):void 0,a.initializer=void 0),void 0===a.initializer&&(Object.defineProperty(e,t,a),a=null),a}let u=(i=c.Command.String(),r=c.Command.Path("nixify","fetch-one"),s=class extends c.Command{constructor(...e){var t;super(...e),(t=o)&&Object.defineProperty(this,"locatorHash",{enumerable:t.enumerable,configurable:t.configurable,writable:t.writable,value:t.initializer?t.initializer.call(this):void 0})}async execute(){const e=await l.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await l.Project.find(e,this.context.cwd),n=await l.Cache.find(e),i=e.makeFetcher();return(await l.StreamReport.start({configuration:e,stdout:this.context.stdout},async e=>{const r=t.originalPackages.get(this.locatorHash);r?await i.fetch(r,{checksums:t.storedChecksums,project:t,cache:n,fetcher:i,report:e}):e.reportError(0,"Invalid locator hash")})).exitCode()}},o=p((a=s).prototype,"locatorHash",[i],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),p(a.prototype,"execute",[r],Object.getOwnPropertyDescriptor(a.prototype,"execute"),a.prototype),a);var d,h,f,y,b,g=n(688),x=n(417),m=n(798);function P(e,t,n,i,r){var a={};return Object.keys(i).forEach((function(e){a[e]=i[e]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=n.slice().reverse().reduce((function(n,i){return i(e,t,n)||n}),a),r&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(r):void 0,a.initializer=void 0),void 0===a.initializer&&(Object.defineProperty(e,t,a),a=null),a}const v=["pnp","node-modules"];let w=(d=c.Command.String(),h=c.Command.Path("nixify","install-bin"),b=class extends c.Command{constructor(...e){var t;super(...e),(t=y)&&Object.defineProperty(this,"binDir",{enumerable:t.enumerable,configurable:t.configurable,writable:t.writable,value:t.initializer?t.initializer.call(this):void 0})}async execute(){const e=await l.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:n}=await l.Project.find(e,this.context.cwd);return(await l.StreamReport.start({configuration:e,stdout:this.context.stdout},async i=>{if(!n||0===n.manifest.bin.size)return;let r=e.get("nodeLinker");v.includes(r)||(r="node-modules",i.reportWarning(0,`The nodeLinker ${r} is not supported - executables may have trouble finding dependencies`));const a=g.npath.toPortablePath(this.binDir),o=(0,m.getPnpPath)(t).main;for(const[e,i]of n.manifest.bin){const n=g.ppath.join(a,e),s=g.ppath.join(t.cwd,g.npath.toPortablePath(i));let c;switch(r){case"pnp":c="#!/bin/sh\nexport NODE_OPTIONS=\"--require @@PNP_PATH@@\"\nexec '@@NODE_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n".replace("@@NODE_PATH@@",process.execPath).replace("@@PNP_PATH@@",o).replace("@@SCRIPT_PATH@@",s);break;case"node-modules":c="#!/bin/sh\nexec '@@NODE_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n".replace("@@NODE_PATH@@",process.execPath).replace("@@SCRIPT_PATH@@",s);break;default:throw Error("Invalid nodeLinker "+r)}g.xfs.writeFileSync(n,c),g.xfs.chmodSync(n,493)}})).exitCode()}},y=P((f=b).prototype,"binDir",[d],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),P(f.prototype,"execute",[h],Object.getOwnPropertyDescriptor(f.prototype,"execute"),f.prototype),f);const N=(e,t)=>(0,x.createHash)(e).update(t).digest(),S=(e,t,n,i="/nix/store")=>{const r=n.toString("hex"),a=N("sha256",`fixed:out:${t}:${r}:`).toString("hex"),o=(e=>{let t="",n=[...e].reverse().map(e=>e.toString(2).padStart(8,"0")).join("");for(;n;)t+="0123456789abcdfghijklmnpqrsvwxyz"[parseInt(n.slice(0,5),2)],n=n.slice(5);return t})(((e,t)=>{const n=Buffer.alloc(20);for(let t=0;t<e.length;t++)n[t%20]^=e[t];return n})(N("sha256",`output:out:sha256:${a}:${i}:${e}`)));return g.ppath.join(i,`${o}-${e}`)};var $=n(87);const k={commands:[u,w],hooks:{afterAllInstalled:async(e,t)=>{!1!==t.persistProject&&e.configuration.get("enableNixify")&&await(async(e,t,n)=>{const{configuration:i,cwd:r}=e,a=g.xfs.realpathSync(g.npath.toPortablePath((0,$.tmpdir)()));if(e.cwd.startsWith(a))return void n.reportInfo(0,`Skipping Nixify, because ${e.cwd} appears to be a temporary directory`);const o=i.get("yarnPath");let s=g.ppath.relative(r,o);s.startsWith("../")&&(s=o,n.reportWarning(0,`The Yarn path ${o} is outside the project - it may not be reachable by the Nix build`));const c=i.get("cacheFolder");let p=g.ppath.relative(r,c);p.startsWith("../")&&(p=c,n.reportWarning(0,`The cache folder ${c} is outside the project - it may not be reachable by the Nix build`));for(const e of i.sources.values())e.startsWith("<")||g.ppath.relative(r,e).startsWith("../")&&n.reportWarning(0,`The config file ${e} is outside the project - it may not be reachable by the Nix build`);let u=[];const d=new Set(g.xfs.readdirSync(t.cwd));for(const n of e.storedPackages.values()){const{version:i,locatorHash:r}=n,a=e.storedChecksums.get(r);if(!a)continue;const o=t.getLocatorPath(n,a);if(!o)continue;const s=g.ppath.basename(o);if(!d.has(s))continue;let c=l.structUtils.slugifyIdent(n).replace(/^@/,"_at_");i&&(c+="-"+i);const p=a.split("/").pop();u.push({name:c,filename:s,sha512:p,locatorHash:r})}const h=e.topLevelWorkspace.manifest.name,f=h?l.structUtils.stringifyIdent(h):"workspace",y="# This file is generated by running \"yarn install\" inside your project.\n# Manual changes might be lost - proceed with caution!\n\n{ lib, coreutils, nodejs, stdenv, writeText }: src:\n\nlet\n\n  yarnPath = @@YARN_PATH@@;\n  cacheFolder = @@CACHE_FOLDER@@;\n  cacheEntries = @@CACHE_ENTRIES@@;\n\n  # Fetch a single dependency.\n  fetchOne = let\n    builder = builtins.toFile \"builder.sh\" ''\n      source $stdenv/setup\n      cd \"$src\"\n      HOME=\"$TMP\" yarn_cache_folder=\"$TMP\" CI=1 \\\n        node '${yarnPath}' nixify fetch-one $locatorHash\n      mv \"$TMP/$outputFilename\" $out\n    '';\n  in { name, filename, sha512, locatorHash }: stdenv.mkDerivation {\n    inherit name src builder locatorHash;\n    buildInputs = [ nodejs ];\n    outputFilename = filename;\n    outputHashMode = \"flat\";\n    outputHashAlgo = \"sha512\";\n    outputHash = sha512;\n  };\n\n  # Shell snippet to collect all project dependencies.\n  collectCacheScript = writeText \"collect-cache.sh\" (\n    lib.concatMapStrings (args: ''\n      cp ${fetchOne args} '${args.filename}'\n    '') cacheEntries\n  );\n\nin stdenv.mkDerivation {\n  name = @@PROJECT_NAME@@;\n  inherit src;\n\n  # Disable Nixify plugin to save on some unnecessary processing.\n  yarn_enable_nixify = \"false\";\n  # Tell node-gyp to use the provided Node.js headers for native code builds.\n  npm_config_nodedir = nodejs;\n  # Tell node-pre-gyp to never fetch binaries / always build from source.\n  npm_config_build_from_source = \"true\";\n\n  # Make sure the build uses the right Node.js version everywhere.\n  buildInputs = [ nodejs ];\n\n  # Defines the shell alias to run Yarn.\n  postHook = ''\n    yarn() {\n      CI=1 node \"$NIX_YARN_PATH\" \"$@\"\n    }\n  '';\n\n  configurePhase = ''\n    runHook preConfigure\n\n    # Copy over the Yarn cache.\n    rm -fr '${cacheFolder}'\n    mkdir -p '${cacheFolder}'\n    pushd '${cacheFolder}' > /dev/null\n    source ${collectCacheScript}\n    popd > /dev/null\n\n    # Store the absolute path to Yarn for the 'yarn' alias.\n    export NIX_YARN_PATH=\"$(readlink -f '${yarnPath}')\"\n\n    # Run normal Yarn install to complete dependency installation.\n    yarn install --immutable --immutable-cache\n\n    runHook postConfigure\n  '';\n\n  buildPhase = ''\n    runHook preBuild\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/libexec $out/bin\n\n    # Move the entire project to the output directory.\n    mv $PWD \"$out/libexec/$sourceRoot\"\n    cd \"$out/libexec/$sourceRoot\"\n\n    # Update the path to Yarn.\n    export NIX_YARN_PATH=\"$(readlink -f '${yarnPath}')\"\n\n    # Invoke a plugin internal command to setup binaries.\n    yarn nixify install-bin $out/bin\n\n    runHook postInstall\n  '';\n\n  passthru = {\n    inherit nodejs;\n  };\n}\n".replace("@@PROJECT_NAME@@",JSON.stringify(f)).replace("@@YARN_PATH@@",JSON.stringify(s)).replace("@@CACHE_FOLDER@@",JSON.stringify(p)).replace("@@CACHE_ENTRIES@@","[\n"+u.map(e=>`    { ${(e=>[`name = ${JSON.stringify(e.name)};`,`filename = ${JSON.stringify(e.filename)};`,`sha512 = ${JSON.stringify(e.sha512)};`,`locatorHash = ${JSON.stringify(e.locatorHash)};`].join(" "))(e)} }\n`).sort().join("")+"  ]");if(g.xfs.writeFileSync(i.get("nixExprPath"),y),i.get("generateDefaultNix")){const e=g.ppath.join(r,"default.nix"),t=g.ppath.join(r,"flake.nix");g.xfs.existsSync(e)||g.xfs.existsSync(t)||(g.xfs.writeFileSync(e,"# This is a minimal `default.nix` by yarn-plugin-nixify. You can customize it\n# as needed, it will not be overwritten by the plugin.\n\n{ pkgs ? import <nixpkgs> { } }:\n\npkgs.callPackage ./yarn-project.nix { } ./.\n"),n.reportInfo(0,"A minimal default.nix was created. You may want to customize it."))}i.get("enableNixPreload")&&g.xfs.existsSync(g.npath.toPortablePath("/nix/store"))&&await g.xfs.mktempPromise(async i=>{const r=[];for(const{name:e,filename:n,sha512:a}of u){const o=Buffer.from(a,"hex"),s=S(e,"sha512",o);if(!g.xfs.existsSync(s)){const o=g.ppath.join(i,a.slice(0,7));await g.xfs.mkdirPromise(o);const s=g.ppath.join(t.cwd,n),c=g.ppath.join(o,e);await g.xfs.copyFilePromise(s,c),r.push(c)}}try{const t=r.length;for(;0!==r.length;){const t=r.splice(0,100);await l.execUtils.execvp("nix-store",["--add-fixed","sha512",...t],{cwd:e.cwd,strict:!0})}0!==t&&n.reportInfo(0,`Preloaded ${t} packages into the Nix store`)}catch(e){if("ENOENT"!==e.code)throw e}})})(e,t.cache,t.report)}},configuration:{enableNixify:{description:"If false, disables the Nixify plugin hook that generates Nix expressions",type:l.SettingsType.BOOLEAN,default:!0},nixExprPath:{description:"Path of the file where the project Nix expression will be written to",type:l.SettingsType.ABSOLUTE_PATH,default:"./yarn-project.nix"},generateDefaultNix:{description:"If true, a default.nix will be generated if it does not exist",type:l.SettingsType.BOOLEAN,default:!0},enableNixPreload:{description:"If true, cached packages will be preloaded into the Nix store",type:l.SettingsType.BOOLEAN,default:!0}}}},966:t=>{t.exports=e("@yarnpkg/core")},688:t=>{t.exports=e("@yarnpkg/fslib")},798:t=>{t.exports=e("@yarnpkg/plugin-pnp")},42:t=>{t.exports=e("clipanion")},417:t=>{t.exports=e("crypto")},87:t=>{t.exports=e("os")}},n={};function i(e){if(n[e])return n[e].exports;var r=n[e]={exports:{}};return t[e](r,r.exports,i),r.exports}return i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i(540)})()}};